<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sugar Smash ‚Äî Swipe Match-3</title>
<style>
  :root{
    --bg1:#0f2027; --bg2:#2a5298;
    --panel:#0f2732; --accent:#ffcc00;
    --cell:54px;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:linear-gradient(135deg,var(--bg1),var(--bg2)); color:#fff}
  .wrap{max-width:980px;margin:18px auto;padding:14px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  select,button{background:rgba(255,255,255,0.04);border:0;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer}
  .hud{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;align-items:center}
  .badge{background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px}
  main{display:flex;gap:18px;margin-top:14px;flex-wrap:wrap;align-items:flex-start}
  .board-wrap{background:rgba(255,255,255,0.02);padding:12px;border-radius:12px}
  #board{display:grid;grid-gap:6px;touch-action: none}
  .cell{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;border-radius:10px;background:#111;font-size:26px;user-select:none;-webkit-user-select:none;transition:transform .18s,opacity .18s}
  .cell.selected{outline:3px solid rgba(255,255,255,0.12); transform:scale(1.05)}
  .cell.remove{opacity:0; transform:scale(.6)}
  .sidebar{min-width:220px;padding:12px;background:rgba(255,255,255,0.02);border-radius:12px}
  .big{font-size:26px;color:var(--accent);font-weight:700}
  .small{font-size:13px;opacity:.9}
  #modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:60}
  #modal .card{background:#132025;padding:20px;border-radius:12px;text-align:center}
  #modal button{margin-top:12px}
  /* Candy gradient classes (optional visuals if you later use them) */
  .candy { font-size:24px }
  .candy.red    { background: linear-gradient(135deg, #ff4e50, #f9d423); }
  .candy.blue   { background: linear-gradient(135deg, #24c6dc, #514a9d); }
  .candy.green  { background: linear-gradient(135deg, #56ab2f, #a8e063); }
  .candy.yellow { background: linear-gradient(135deg, #f7971e, #ffd200); }
  .candy.purple { background: linear-gradient(135deg, #654ea3, #eaafc8); }

  @media (max-width:720px){:root{--cell:44px};main{flex-direction:column}.sidebar{width:100%}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Magic Match</h1>
    <div class="controls">
      <select id="level">
        <option value="easy" data-target="1200" data-moves="40">Easy (1200 - 40 moves)</option>
        <option value="medium" data-target="2400" data-moves="30" selected>Medium (2400 - 30 moves)</option>
        <option value="hard" data-target="4000" data-moves="22">Hard (4000 - 22 moves)</option>
      </select>
      <button id="restart">Restart</button>
      <button onclick="location.href='index.html'">üè† Home</button>
    </div>
  </header>

  <!-- single HUD -->
  <div class="hud">
    <div class="badge">Score: <strong id="score">0</strong></div>
    <div class="badge">Moves: <strong id="moves">30</strong></div>
    <div class="badge small">Target: <strong id="target">2400</strong></div>
  </div>

  <main>
    <div class="board-wrap">
      <div id="board" role="grid" aria-label="Match 3 board"></div>
    </div>

    <aside class="sidebar">
      <div class="big" id="levelLabel">Medium</div>
      <p class="small">Tap a candy then swipe or tap an adjacent candy to swap. Make lines of 3+ to clear them. Candies fall and refill. Match bigger chains and combos for extra points.</p>
      <hr style="opacity:.06;border:none;height:8px">
      <div class="small"><strong>Scoring</strong>: 3 = 100pts, +50 per extra candy in same match. Combo cascades add bonus.</div>
    </aside>
  </main>
</div>

<!-- Modal -->
<div id="modal" aria-hidden="true">
  <div class="card">
    <div id="modalMessage" style="font-size:18px;margin-bottom:8px"></div>
    <div style="display:flex;gap:8px;justify-content:center">
      <button id="playAgain">Play Again</button>
      <button id="modalHome">Home</button>
    </div>
  </div>
</div>

<!-- pop sound -->
<audio id="popSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>

<script>
/* =========================
   Config & State
========================= */
const GRID = 6;
const candies = ['üçí','üçã','üçä','üçè','üçá','üç¨','üç≠','üç©'];
const boardEl   = document.getElementById('board');
const scoreEl   = document.getElementById('score');
const movesEl   = document.getElementById('moves');
const targetEl  = document.getElementById('target');
const levelSelect = document.getElementById('level');
const restartBtn  = document.getElementById('restart');
const levelLabel  = document.getElementById('levelLabel');
const popSound = document.getElementById('popSound');

let grid = [];           // 2D array of { candy, el }
let selected = null;
let score = 0;
let movesLeft = 30;
let targetScore = 2400;
let busy = false;

// swipe capture
let touchStart = null; // {r,c,x,y,id}
let SWIPE_MIN = 14;    // slightly more sensitive for short swipes

/* =========================
   Helpers (DOM & utils)
========================= */
function randomCandy(){ return candies[Math.floor(Math.random()*candies.length)]; }
function wait(ms){ return new Promise(r => setTimeout(r, ms)); }
function updateHUD(){ scoreEl.textContent = score; movesEl.textContent = movesLeft; targetEl.textContent = targetScore; }
function inBounds(r,c){ return r>=0 && r<GRID && c>=0 && c<GRID; }
function areAdjacent(r1,c1,r2,c2){ return (Math.abs(r1-r2)+Math.abs(c1-c2))===1; }
function swap(r1,c1,r2,c2){
  const t = grid[r1][c1].candy;
  grid[r1][c1].candy = grid[r2][c2].candy;
  grid[r2][c2].candy = t;
}

/* =========================
   Setup & Rendering
========================= */
function applyLevel(){
  const opt = levelSelect.selectedOptions[0];
  targetScore = Number(opt.dataset.target);
  movesLeft   = Number(opt.dataset.moves);
  levelLabel.textContent = opt.text.split('(')[0].trim();
  score = 0;
  updateHUD();
}

function makeBoard(){
  boardEl.style.gridTemplateColumns = `repeat(${GRID}, var(--cell))`;
  boardEl.innerHTML = '';
  grid = Array.from({length:GRID}, (_,r) =>
    Array.from({length:GRID}, (_,c) => {
      const el = document.createElement('div');
      el.className = 'cell';
      el.dataset.r = r; el.dataset.c = c;
      el.addEventListener('pointerdown', onPointerStart);
      el.addEventListener('pointerup',   onPointerEnd);
      el.addEventListener('pointercancel', onPointerCancel);
      el.addEventListener('click', onClick);
      boardEl.appendChild(el);
      return { candy: randomCandy(), el };
    })
  );
  resolveInitial().then(render);
}

function render(){
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      const cell = grid[r][c];
      cell.el.textContent = cell.candy;
      // ensure classes are reset
      cell.el.classList.remove('selected','remove');
    }
  }
  updateHUD();
}

/* Make sure starting board has no instant matches */
async function resolveInitial(){
  let attempts = 0;
  while(true){
    const m = findAllMatches();
    if (!m.length) break;
    m.forEach(set => set.forEach(p => grid[p.r][p.c].candy = randomCandy()));
    attempts++; if (attempts>20) break;
  }
}

/* =========================
   Input (click / swipe)
========================= */
function onPointerStart(e){
  if (busy) return;
  const el = e.currentTarget;
  el.setPointerCapture(e.pointerId);
  const r = +el.dataset.r, c = +el.dataset.c;
  touchStart = { r,c, x: e.clientX, y: e.clientY, id: e.pointerId };
}
function onPointerEnd(e){
  if (!touchStart || touchStart.id !== e.pointerId){ touchStart=null; return; }
  const el = e.currentTarget;
  const dx = e.clientX - touchStart.x, dy = e.clientY - touchStart.y;

  if (Math.abs(dx) > SWIPE_MIN || Math.abs(dy) > SWIPE_MIN){
    let dr=0, dc=0;
    if (Math.abs(dx) > Math.abs(dy)) dc = dx>0?1:-1; else dr = dy>0?1:-1;
    const rTarget = touchStart.r + dr;
    const cTarget = touchStart.c + dc;
    if (inBounds(rTarget,cTarget)){
      handleSwap(touchStart.r,touchStart.c,rTarget,cTarget);
    }
  }
  touchStart = null;
  try{ e.currentTarget.releasePointerCapture(e.pointerId);}catch(_){}
}
function onPointerCancel(){ touchStart=null; }

function onClick(e){
  if (busy) return;
  const el = e.currentTarget;
  const r = +el.dataset.r, c = +el.dataset.c;
  if (!selected){
    selected = {r,c,el};
    el.classList.add('selected');
    return;
  }
  if (selected.r === r && selected.c === c){
    selected.el.classList.remove('selected');
    selected = null;
    return;
  }
  if (areAdjacent(selected.r,selected.c,r,c)){
    handleSwap(selected.r, selected.c, r, c);
  } else {
    selected.el.classList.remove('selected');
    selected = {r,c,el};
    el.classList.add('selected');
  }
}

/* =========================
   Match Logic
========================= */
function findAllMatches(){
  const matches = [];
  // horizontal
  for (let r=0;r<GRID;r++){
    let runCandy = null, runStart=0, runLen=0;
    for (let c=0;c<=GRID;c++){
      const candy = c<GRID ? grid[r][c].candy : null;
      if (candy === runCandy){ runLen++; }
      else {
        if (runCandy !== null && runLen>=3){
          const set=[]; for(let k=0;k<runLen;k++) set.push({r,c:runStart+k});
          matches.push(set);
        }
        runCandy=candy; runStart=c; runLen=1;
      }
    }
  }
  // vertical
  for (let c=0;c<GRID;c++){
    let runCandy = null, runStart=0, runLen=0;
    for (let r=0;r<=GRID;r++){
      const candy = r<GRID ? grid[r][c].candy : null;
      if (candy === runCandy){ runLen++; }
      else {
        if (runCandy !== null && runLen>=3){
          const set=[]; for(let k=0;k<runLen;k++) set.push({r:runStart+k,c});
          matches.push(set);
        }
        runCandy=candy; runStart=r; runLen=1;
      }
    }
  }
  return matches;
}

/* Any possible move that would yield a match? */
function hasPossibleMove(){
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      // try right
      if (c+1<GRID){
        swap(r,c,r,c+1);
        if (findAllMatches().length){ swap(r,c,r,c+1); return true; }
        swap(r,c,r,c+1);
      }
      // try down
      if (r+1<GRID){
        swap(r,c,r+1,c);
        if (findAllMatches().length){ swap(r,c,r+1,c); return true; }
        swap(r,c,r+1,c);
      }
    }
  }
  return false;
}

/* Shuffle until there are valid moves and no instant matches */
function shuffleBoard(){
  let flat = [];
  for(let r=0;r<GRID;r++) for(let c=0;c<GRID;c++) flat.push(grid[r][c].candy);

  let attempts = 0;
  do {
    // Fisher‚ÄìYates shuffle
    for(let i=flat.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [flat[i],flat[j]] = [flat[j],flat[i]];
    }
    // refill
    let k=0;
    for(let r=0;r<GRID;r++) for(let c=0;c<GRID;c++) grid[r][c].candy = flat[k++];
    attempts++;
  } while ((findAllMatches().length || !hasPossibleMove()) && attempts<50);

  render();
}

/* Drop and refill (gravity) */
async function collapseFill(){
  for (let c=0;c<GRID;c++){
    let write = GRID-1;
    for (let r=GRID-1;r>=0;r--){
      if (grid[r][c].candy !== null){
        if (write !== r){
          grid[write][c].candy = grid[r][c].candy;
        }
        write--;
      }
    }
    for (let r=write;r>=0;r--){
      grid[r][c].candy = randomCandy();
    }
  }
}

/* Core resolution loop: remove, score, drop, refill until stable */
async function processMatchesLoop(){
  let combo = 0;
  while(true){
    const matches = findAllMatches();
    if (!matches.length) break;

    combo++;

    // unique positions
    const removeMap = {};
    matches.forEach(set => set.forEach(p => removeMap[`${p.r},${p.c}`]=p));
    const positions = Object.values(removeMap);

    // visuals: add remove class
    positions.forEach(p => grid[p.r][p.c].el.classList.add('remove'));

    // play pop sound
    try { popSound.currentTime = 0; popSound.play(); } catch(e){}

    await wait(180);

    // scoring: 100 per set, +50 per extra beyond 3 in that set, +combo bonus
    let extras = 0;
    matches.forEach(set => { if (set.length>3) extras += (set.length - 3); });
    score += 100*matches.length + 50*extras + (combo-1)*50;

    // remove candies logically
    positions.forEach(p => grid[p.r][p.c].candy = null);

    render();
    await wait(90);

    // gravity + refill
    await collapseFill();
    render();
    await wait(120);
  }

  // If stuck, shuffle
  if (!hasPossibleMove()){
    await wait(250);
    shuffleBoard();
  }
}

/* =========================
   Swapping
========================= */
async function handleSwap(r1,c1,r2,c2){
  if (busy) return;
  busy = true;
  if (selected && selected.el) selected.el.classList.remove('selected');
  selected = null;

  swap(r1,c1,r2,c2);
  render();
  await wait(150);

  const matches = findAllMatches();
  if (!matches.length){
    // revert if no match
    swap(r1,c1,r2,c2);
    render();
    busy = false;
    return;
  }

  // valid move consumes a move
  movesLeft = Math.max(0, movesLeft-1);
  await processMatchesLoop();
  render();
  checkEnd();

  busy = false;
}

/* =========================
   Endgame & Modal
========================= */
function checkEnd(){
  if (score >= targetScore){
    showModal(`üéâ You win! Score: ${score}`);
  } else if (movesLeft <= 0){
    showModal(`‚õî Out of moves. Score: ${score}`);
  }
}

const modal = document.getElementById('modal');
const modalMessage = document.getElementById('modalMessage');
document.getElementById('playAgain').addEventListener('click', ()=>{ modal.style.display='none'; restartGame(); });
document.getElementById('modalHome').addEventListener('click', ()=> location.href='index.html');

function showModal(msg){
  modalMessage.textContent = msg;
  modal.style.display = 'flex';
}

/* =========================
   Boot / Controls
========================= */
function clearSelection(){ if (selected){ selected.el.classList.remove('selected'); selected=null; } }

function restartGame(){
  applyLevel();
  clearSelection();
  makeBoard();
  render();
  modal.style.display = 'none';
}

restartBtn.addEventListener('click', restartGame);
levelSelect.addEventListener('change', restartGame);

// Optional keyboard nudges (desktop)
document.addEventListener('keydown', e=>{
  if (busy || !selected) return;
  const r = selected.r, c = selected.c;
  if (e.key === 'ArrowLeft'  && inBounds(r,c-1)) handleSwap(r,c,r,c-1);
  if (e.key === 'ArrowRight' && inBounds(r,c+1)) handleSwap(r,c,r,c+1);
  if (e.key === 'ArrowUp'    && inBounds(r-1,c)) handleSwap(r,c,r-1,c);
  if (e.key === 'ArrowDown'  && inBounds(r+1,c)) handleSwap(r,c,r+1,c);
});

// start
applyLevel();
makeBoard();
render();
</script>
</body>
</html>
