<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Match-3 (Candy)</title>
<style>
  :root{
    --bg:#0f2027;
    --card:#111;
    --panel:#122935;
    --accent:#ffcc00;
    --cell-size:44px;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#fff;background:linear-gradient(135deg,var(--bg),#2a5298);-webkit-font-smoothing:antialiased}
  .wrap{max-width:980px;margin:20px auto;padding:16px}
  header{display:flex;align-items:center;gap:12px;justify-content:space-between}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  button,select{background:var(--panel);color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .hud{display:flex;gap:12px;align-items:center;margin-top:12px;flex-wrap:wrap}
  .badge{background:rgba(255,255,255,0.04);padding:8px 12px;border-radius:10px;font-weight:700}
  main{display:flex;gap:18px;margin-top:16px;align-items:flex-start;flex-wrap:wrap}
  .board-wrap{background:rgba(255,255,255,0.03);padding:12px;border-radius:12px}
  #board{display:grid;grid-gap:6px;touch-action: manipulation}
  .cell{
    width:var(--cell-size);height:var(--cell-size);
    display:flex;align-items:center;justify-content:center;
    font-size:22px;border-radius:8px; background:var(--card);
    user-select:none; -webkit-user-select:none;
    transition:transform .12s ease, opacity .18s ease;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3) inset;
  }
  .cell.selected{outline:3px solid rgba(255,255,255,0.12); transform:scale(1.04)}
  .cell.removing{opacity:0; transform:scale(.85)}
  .sidebar{min-width:200px;padding:12px;background:rgba(255,255,255,0.02);border-radius:12px}
  .big{font-size:28px;font-weight:800;color:var(--accent)}
  .small{font-size:13px;opacity:.9}
  footer{margin-top:18px;text-align:center;opacity:.8;font-size:13px}
  @media (max-width:720px){
    :root{--cell-size:44px}
    main{flex-direction:column;align-items:center}
    .sidebar{width:100%}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>CampBell ‚Äî Mini Match-3</h1>
    <div class="controls">
      <select id="levelSelect" title="Choose level">
        <option value="1" data-target="1200" data-moves="35">Easy (Target 1200 - 35 moves)</option>
        <option value="2" data-target="2400" data-moves="30" selected>Medium (Target 2400 - 30 moves)</option>
        <option value="3" data-target="4000" data-moves="25">Hard (Target 4000 - 25 moves)</option>
      </select>
      <button id="restartBtn">Restart</button>
      <button onclick="location.href='index.html'">üè† Home</button>
    </div>
  </header>

  <div class="hud">
    <div class="badge">Score: <span id="score">0</span></div>
    <div class="badge">Moves left: <span id="moves">30</span></div>
    <div class="badge small">Target: <span id="target">2400</span></div>
  </div>

  <main>
    <div class="board-wrap">
      <div id="board" aria-label="Match-3 board"></div>
    </div>

    <aside class="sidebar">
      <div class="small">How to play</div>
      <p class="small">Tap one candy then tap an adjacent candy to swap. Make matches of 3 or more to score. Matches clear, candies fall and new candies appear.</p>
      <div style="height:14px"></div>
      <div class="small">Scoring</div>
      <p class="small">3 match = 100pts, +50 per extra candy in the same match. Combo cascades give extra points.</p>
      <div style="height:12px"></div>
      <div><strong>Level:</strong> <span id="levelLabel">Medium</span></div>
      <div style="height:8px"></div>
      <div class="small">Mobile tip: tap to select & tap adjacent cell to swap</div>
    </aside>
  </main>

  <footer>Built for web & mobile ‚Äî simple match-3 demo</footer>
</div>

<script>
/* ======= Simple Match-3 implementation =======
  - Grid sized NxN (configurable)
  - Candies: emoji set, randomized
  - Click/tap to select a cell, click adjacent to swap
  - Detect horizontal/vertical matches (>=3)
  - Remove, drop, fill, cascade
  - Scoring + moves + target
*/

const GRID_SIZE = 8; // 8x8 board
const emojiSet = ['üçí','üçã','üçä','üçè','üçá','üç¨','üç≠','üç©']; // candies
const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const targetEl = document.getElementById('target');
const levelSelect = document.getElementById('levelSelect');
const restartBtn = document.getElementById('restartBtn');
const levelLabel = document.getElementById('levelLabel');

let grid = []; // 2D array of candies (strings)
let selected = null; // {r,c,el}
let score = 0;
let movesLeft = 30;
let targetScore = 2400;
let busy = false;

function makeBoard() {
  boardEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, var(--cell-size))`;
  boardEl.innerHTML = '';
  grid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(null));
  for (let r=0;r<GRID_SIZE;r++){
    for (let c=0;c<GRID_SIZE;c++){
      const el = document.createElement('div');
      el.className = 'cell';
      el.dataset.r = r; el.dataset.c = c;
      el.addEventListener('click', onCellClick);
      el.addEventListener('touchstart', onCellClick);
      boardEl.appendChild(el);
      grid[r][c] = { candy: randomCandy(), el };
    }
  }
  // Avoid initial matches by resolving any existing matches
  resolveInitialMatches().then(()=> render());
}

function randomCandy(){
  return emojiSet[Math.floor(Math.random()*emojiSet.length)];
}

function render(){
  for (let r=0;r<GRID_SIZE;r++){
    for (let c=0;c<GRID_SIZE;c++){
      const cell = grid[r][c];
      cell.el.textContent = cell.candy;
      cell.el.classList.remove('selected','removing');
    }
  }
  scoreEl.textContent = score;
  movesEl.textContent = movesLeft;
  targetEl.textContent = targetScore;
  const levelText = levelSelect.selectedOptions[0].text;
  levelLabel.textContent = levelText.split('(')[0].trim();
}

function onCellClick(evt){
  if (busy) return;
  const el = evt.currentTarget;
  const r = +el.dataset.r, c = +el.dataset.c;
  if (!selected) {
    selected = {r,c, el};
    el.classList.add('selected');
    return;
  }
  // if same cell => deselect
  if (selected.r===r && selected.c===c) {
    el.classList.remove('selected');
    selected = null;
    return;
  }
  // must be adjacent
  if (!areAdjacent(selected.r, selected.c, r, c)) {
    // swap selection
    selected.el.classList.remove('selected');
    selected = {r,c,el};
    el.classList.add('selected');
    return;
  }
  // perform swap
  swapAndResolve(selected.r, selected.c, r, c);
}

function areAdjacent(r1,c1,r2,c2){
  return (Math.abs(r1-r2)+Math.abs(c1-c2))===1;
}

/* swap and if no match, undo (like Candy Crush) */
async function swapAndResolve(r1,c1,r2,c2){
  busy = true;
  toggleSelected(null);
  swapCells(r1,c1,r2,c2);
  render();
  const matches = findAllMatches();
  if (matches.length === 0) {
    // no match => revert after small delay
    await wait(180);
    swapCells(r1,c1,r2,c2);
    render();
    busy = false;
    return;
  }
  // valid move
  movesLeft = Math.max(0, movesLeft - 1);
  await processMatchesLoop();
  busy = false;
  checkEndConditions();
}

/* swap helpers */
function swapCells(r1,c1,r2,c2){
  const a = grid[r1][c1], b = grid[r2][c2];
  const tmp = a.candy; a.candy = b.candy; b.candy = tmp;
}

/* find matches: returns array of sets [{r,c},...] */
function findAllMatches(){
  const matches = [];
  const seen = Array.from({length:GRID_SIZE},()=>Array(GRID_SIZE).fill(false));

  // horizontal
  for (let r=0;r<GRID_SIZE;r++){
    let runCandy = null, runStart=0, runLen=0;
    for (let c=0;c<=GRID_SIZE;c++){
      const candy = c<GRID_SIZE? grid[r][c].candy : null;
      if (candy === runCandy) {
        runLen++;
      } else {
        if (runCandy !== null && runLen>=3){
          const set = [];
          for (let k=0;k<runLen;k++) set.push({r, c: runStart + k});
          matches.push(set);
        }
        runCandy = candy;
        runStart = c;
        runLen = 1;
      }
    }
  }
  // vertical
  for (let c=0;c<GRID_SIZE;c++){
    let runCandy = null, runStart=0, runLen=0;
    for (let r=0;r<=GRID_SIZE;r++){
      const candy = r<GRID_SIZE? grid[r][c].candy : null;
      if (candy === runCandy) {
        runLen++;
      } else {
        if (runCandy !== null && runLen>=3){
          const set = [];
          for (let k=0;k<runLen;k++) set.push({r: runStart + k, c});
          matches.push(set);
        }
        runCandy = candy;
        runStart = r;
        runLen = 1;
      }
    }
  }
  return matches;
}

/* process matches loop: remove, drop, fill, repeat until no matches */
async function processMatchesLoop(){
  let combo = 0;
  while(true){
    const matches = findAllMatches();
    if (!matches.length) break;
    combo++;
    // flatten unique positions
    const toRemove = {};
    matches.forEach(set => set.forEach(pos => toRemove[`${pos.r},${pos.c}`]=pos));
    const positions = Object.values(toRemove);
    // mark removing visually
    positions.forEach(p => grid[p.r][p.c].el.classList.add('removing'));
    await wait(160);
    // scoring
    const base = 100;
    const extra = positions.length - (3 * matches.length);
    score += base * matches.length + (50 * extra) + (combo-1)*50;
    // actually remove: set candies to null
    positions.forEach(p => grid[p.r][p.c].candy = null);
    render();
    await wait(80);
    await collapseAndFill();
    render();
    await wait(120);
  }
}

/* collapse columns (gravity) and fill new candies */
async function collapseAndFill(){
  for (let c=0;c<GRID_SIZE;c++){
    let write = GRID_SIZE - 1;
    for (let r=GRID_SIZE-1;r>=0;r--){
      if (grid[r][c].candy !== null){
        if (write !== r){
          grid[write][c].candy = grid[r][c].candy;
        }
        write--;
      }
    }
    for (let r=write;r>=0;r--){
      grid[r][c].candy = randomCandy();
    }
  }
}

/* small helper */
function wait(ms){ return new Promise(res=>setTimeout(res, ms)); }

/* initial match resolver to avoid starting matches */
async function resolveInitialMatches(){
  let loop=0;
  while(true){
    const matches = findAllMatches();
    if (!matches.length) break;
    // break matches by shuffling some candies
    matches.forEach(set => set.forEach(pos => grid[pos.r][pos.c].candy = randomCandy()));
    loop++; if (loop>6) break;
  }
}

/* check win/lose */
function checkEndConditions(){
  if (score >= targetScore){
    showModal(`üéâ You hit the target! Score: ${score}`);
    return;
  }
  if (movesLeft <= 0){
    showModal(`‚õî Out of moves! Score: ${score}`);
  }
}

/* modal */
function showModal(text){
  setTimeout(()=> alert(text), 50); // simple alert for now (you can replace with a nice modal)
}

/* utility to clear selection */
function toggleSelected(next){
  if (selected && selected.el) selected.el.classList.remove('selected');
  selected = next;
}

/* level handling & restart */
function applyLevel(){
  const opt = levelSelect.selectedOptions[0];
  targetScore = Number(opt.dataset.target);
  movesLeft = Number(opt.dataset.moves);
  levelLabel.textContent = opt.text.split('(')[0].trim();
  score = 0;
}
levelSelect.addEventListener('change', ()=> {
  applyLevel();
  makeBoard();
  render();
});
restartBtn.addEventListener('click', ()=> {
  applyLevel();
  makeBoard();
  render();
});

/* keyboard swap (optional) - not needed, but good for desktop)
   arrow keys to move selection? Not implemented to keep controls simple.
*/

/* init */
applyLevel();
makeBoard();
render();

</script>
</body>
</html>
